/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * Learn more about Gradle by exploring our samples at https://docs.gradle.org/7.6.4/samples
 */
import java.text.SimpleDateFormat

//allprojects {
//    version = "1.0.0"
//    apply plugin: "java-library"
//}

version = "1.0.0"
apply plugin: "java-library"

def getGitCommitDetails(length = 8) {
    try {
        def gitFolder = "$projectDir/.git/"
        if (!file(gitFolder).isDirectory()) {
            gitFolder = file(gitFolder).text.substring(length).trim() + "/"
        }
        def takeFromHash = length
        def head = new File(gitFolder + "HEAD").text.split(":")
        def isCommit = head.length == 1

        def commitHash, refHeadFile
        if (isCommit) {
            commitHash = head[0].trim().take(takeFromHash)
            refHeadFile = new File(gitFolder + "HEAD")
        } else {
            refHeadFile = new File(gitFolder + head[1].trim())
            commitHash = refHeadFile.text.trim().take(takeFromHash)
        }

        // Use head file modification time as a proxy for the build date
        def lastModified = new Date(refHeadFile.lastModified())
        // Format the date as "yy.M" (e.g. 24.3 for March 2024)
        def formattedDate = new SimpleDateFormat("yy.M").format(lastModified)

        return [hash: commitHash, date: formattedDate]
    } catch (Exception e) {
        logger.warn('Could not calculate git commit details, using defaults (run with --info for stacktrace)')
        logger.info('Error retrieving git commit details', e)
        return [hash: "xxxxxxxx", date: "00.0"]
    }
}

// http://label-schema.org/rc1/
// using the RFC3339 format "2016-04-12T23:20:50.52Z"
def buildTime() {
    def df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'")
    df.setTimeZone(TimeZone.getTimeZone("UTC"))
    return df.format(new Date())
}

// set the shell command to use according to os
def shell = org.gradle.internal.os.OperatingSystem.current().isWindows() ? "${projectDir}\\wslsh.bat" : '/bin/bash'

def dockerBuildVersion = project.hasProperty('release.releaseVersion') ? project.getProperty('release.releaseVersion') : "${version}"
def dockerOrgName = project.hasProperty('dockerOrgName') ? project.getProperty("dockerOrgName") : "tronprotocol"
def dockerArtifactName = project.hasProperty("dockerArtifactName") ? project.getProperty("dockerArtifactName") : "java-tron"
def dockerImageName = "${dockerOrgName}/${dockerArtifactName}"

task sourceDocker {
    def dockerBuildDir = "build/docker-tron/"

    doLast {
        copy {
            from file("${projectDir}/docker/Dockerfile")
            into(dockerBuildDir)
        }
        copy {
            from file("${projectDir}/docker/docker-entrypoint.sh")
            into "${dockerBuildDir}"
        }
        exec {
            def image = "${dockerImageName}:${dockerBuildVersion}"
            def dockerPlatform = ""
            if (project.hasProperty('docker-platform')){
                dockerPlatform = "--platform ${project.getProperty('docker-platform')}"
                println "Building for platform ${project.getProperty('docker-platform')}"
            } else {
                dockerPlatform = "--platform linux/amd64"
                println "Building for default linux/amd64 platform"
            }
            def gitDetails = getGitCommitDetails(7)
            executable shell
            workingDir dockerBuildDir
            args "-c", "docker build ${dockerPlatform} --build-arg BUILD_DATE=${buildTime()} --build-arg VERSION=${dockerBuildVersion} --build-arg VCS_REF=${gitDetails.hash} -t ${image} ."
        }
    }
}

// Takes the version and if it contains SNAPSHOT, alpha, beta or RC in version then return true indicating an interim build
def isInterimBuild(dockerBuildVersion) {
    return (dockerBuildVersion ==~ /.*-SNAPSHOT/) || (dockerBuildVersion ==~ /.*-alpha/)
            || (dockerBuildVersion ==~ /.*-beta/) || (dockerBuildVersion ==~ /.*-RC.*/)
            || (dockerBuildVersion ==~ /.*develop.*/)
}


task testDocker {
    dependsOn sourceDocker
    def dockerReportsDir = "docker/reports/"

    doFirst {
        new File(dockerReportsDir).mkdir()
    }

    doLast {
        exec {
            def image = project.hasProperty('release.releaseVersion') ? "${dockerImageName}:" + project.property('release.releaseVersion') : "${dockerImageName}:${project.version}"
            workingDir "${projectDir}/docker"
            executable shell
            args "-c", "./test.sh ${image}"
        }
    }
}

// Make sure to `docker login` first
task dockerUpload {
    dependsOn sourceDocker
    def architecture = System.getenv('architecture')
    if (architecture == null) {
        architecture = "amd64" //set default as amd64
    }
    def image = "${dockerImageName}:${dockerBuildVersion}"
    def additionalTags = []

    if (project.hasProperty('branch') && project.property('branch') == 'main') {
        additionalTags.add('develop')
    }

    if (!isInterimBuild(dockerBuildVersion)) {
        additionalTags.add(dockerBuildVersion.split(/\./)[0..1].join('.'))
    }

    doLast {
        exec {
            def archVariantImage = "${image}-${architecture}"
            def cmd = "docker tag '${image}' '${archVariantImage}' && docker push '${archVariantImage}'"
            println "Executing '${cmd}'"
            executable shell
            args "-c", cmd
        }
    }
}

tasks.named('jar') {
    enabled = false
}
